## 최종 프로젝트 계획 문서: LLM 프롬프트용 코드 스니펫 생성 도우미 (v1.3)

**1. 프로젝트 개요**

본 프로젝트는 사용자가 로컬 컴퓨터의 코드 폴더나 파일을 선택하여 그 구조와 내용을 LLM(거대 언어 모델) 프롬프트에 사용하기 적합한 형식으로 쉽게 복사할 수 있도록 돕는 데스크톱 애플리케이션 개발을 목표로 합니다. 사용자는 직관적인 UI를 통해 원하는 파일 및 폴더를 선택하고, `.gitignore` 파일 규칙 등을 적용하여 불필요한 파일을 효율적으로 제외하며, 선택된 콘텐츠의 총 LLM 토큰 수를 실시간으로 확인하여 LLM의 컨텍스트 제한을 효과적으로 관리할 수 있습니다. 또한, 애플리케이션의 자동 업데이트 기능을 통해 사용자는 항상 최신 버전의 프로그램을 손쉽게 사용할 수 있습니다. 최종 결과물은 명확히 정의된 형식 (`<file_map>`, `<file_contents>`)으로 클립보드에 복사되어 즉시 활용 가능함으로써, 개발자와 AI 관련 작업자의 생산성 향상에 기여합니다.

**2. 프로젝트 목표**

*   **효율적인 코드 선택 및 필터링:** 사용자가 GUI(파일 트리 뷰 및 체크박스, 부모/자식 자동 선택 기능 포함)를 통해 LLM 프롬프트에 포함할 코드 파일 및 폴더를 쉽고 정확하게 선택하고, `.gitignore` 규칙 또는 사용자 정의 패턴을 통해 불필요한 파일을 효과적으로 필터링할 수 있도록 합니다.
*   **LLM 컨텍스트 관리:** 선택되고 필터링된 파일들의 총 토큰 수를 실시간으로 계산하고 명확하게 표시하며, 작업 진행 상태(프로그레스 바, 상태 메시지)를 사용자에게 제공하여 LLM의 입력 제한(Context Window)을 초과하지 않도록 적극적으로 지원합니다.
*   **표준화되고 즉시 사용 가능한 출력:** 선택된 파일 구조 (`<file_map>`)와 내용 (`<file_contents>`, 확장자 기반 코드 블록 언어 지정)을 일관되고 미리 정의된 텍스트 형식으로 클립보드에 제공하여, LLM 프롬프트 작성 시 별도의 가공 없이 바로 붙여넣어 사용할 수 있도록 합니다.
*   **최적의 사용자 경험 제공:** 직관적인 UI, 간단한 워크플로우(폴더 열기 -> 필터링 확인 -> 선택 -> 토큰 확인 -> 복사), 명확한 오류 처리 및 로깅, 사용자 설정 관리, 그리고 자동 업데이트 기능을 통해 사용자 편의성을 극대화하고 프로그램 유지보수의 부담을 최소화합니다.

**3. 프로젝트 범위**

**In-Scope (포함되는 기능):**

*   **폴더 로딩 및 트리 뷰 표시:** 로컬 폴더 선택 및 해당 폴더의 파일/하위 폴더 구조를 애플리케이션 내의 확장/축소 가능한 트리 뷰 형태로 시각화. 심볼릭 링크는 링크 자체로 표시 (따라가지 않음), 숨김 파일/폴더는 `.gitignore` 규칙에 따르되 UI 토글 옵션 제공 (선택적). 네트워크 드라이브/로컬 동기화 클라우드 저장소 폴더는 일반 폴더와 동일하게 처리 (성능/오프라인 파일 주의).
*   **개별 선택 기능 (체크박스):**
    *   트리 뷰의 각 항목(파일/폴더) 앞에 체크박스를 제공하여 사용자가 포함할 대상을 개별적으로 선택/해제.
    *   **부모 폴더 체크 시 하위 모든 항목 자동 체크/해제 기능 (높은 우선순위).**
    *   **(권장) 모든 하위 항목 체크 시 부모 폴더 자동 체크 기능.**
*   **파일/폴더 제외 기능:**
    *   로드된 폴더 내에 `.gitignore` 파일이 존재할 경우, 해당 규칙을 자동으로 감지하고 읽어와 파일 및 폴더 필터링에 적용 (스캔, 토큰 계산, 복사 대상에서 제외).
    *   (선택적, 초기 버전 이후 고려) 사용자가 프로그램 설정에서 직접 추가적인 제외 패턴(glob 패턴 등)을 정의하고 관리할 수 있는 기능.
*   **실시간 토큰 수 계산 및 표시:**
    *   사용자가 체크박스를 선택/해제하거나 제외 규칙이 변경될 때마다, 현재 선택되고 필터링된 유효한 텍스트 파일들의 총 LLM 토큰 수를 실시간으로 계산하여 UI의 특정 영역에 명확하게 표시.
    *   **대용량 폴더 작업 시 진행 상태 표시:** 상태 표시줄 메시지 및 프로그레스 바 (모달 또는 상태 표시줄 내)를 통해 사용자에게 피드백 제공.
    *   **토큰 계산 기준 LLM 모델 선택 기능:** OpenAI 모델(`tiktoken` 사용)을 기본으로 하며, 설정에서 다른 모델군(예: Claude, Gemini - 해당 SDK/라이브러리 필요 시 추후 확장) 선택 옵션 제공 고려. (초기 버전은 OpenAI 모델 집중)
*   **클립보드 복사 기능:** "복사" 버튼 클릭 시, **체크박스로 선택되고 제외 규칙에 의해 필터링된 항목들만**을 대상으로 다음 형식의 텍스트를 생성하여 시스템 클립보드에 복사:
    *   **`<file_map>` 형식:** 선택된 루트 폴더명 최상단, 계층 구조는 레벨당 2칸 또는 4칸 공백 들여쓰기, 디렉토리명 뒤에 `/` 추가 (또는 📁 아이콘), 파일명은 그대로 (또는 📄 아이콘).
        ```
        <file_map>
        my-project/
          src/
            main.py
        </file_map>
        ```
    *   **`<file_contents>` 형식:** `File: [상대 경로]\n\`\`\`[언어 식별자]\n[파일 내용]\n\`\`\`\n`. 언어 식별자는 파일 확장자 기반 매핑 테이블(예: `.py`->`python`, `.js`->`javascript`)을 통해 지정. 매핑되지 않는 경우 `text`.
*   **파일 처리:**
    *   텍스트 파일 인코딩 자동 감지 시도 (기본적으로 UTF-8 시도, 실패 시 오류 로깅 및 해당 파일 토큰 계산에서 제외, UI에 경고 아이콘 표시).
    *   바이너리 파일 자동 감지 및 내용 포함 제외 (토큰 계산에서도 제외되며, UI에 바이너리 파일임을 명시).
*   **애플리케이션 자동 업데이트 기능:**
    *   프로그램 시작 시 또는 사용자가 설정한 주기(또는 수동 확인 버튼)에 따라 원격 서버(예: Github Releases API 사용, HTTPS 통신)에서 새 버전 존재 여부 확인. 버전 비교는 유의적 버전 관리(`packaging.version` 사용) 기준.
    *   새 버전이 발견될 경우 사용자에게 명확한 알림(`QMessageBox`) 및 업데이트 진행 여부 동의 확인 (다운로드 페이지 링크 제공 우선).
    *   (고급) 동의 시, 새 버전의 애플리케이션 패키지를 안전하게 다운로드하고, 현재 실행 중인 애플리케이션을 종료 후 자동으로 설치 또는 교체하는 기능 지원 (OS별 권한 및 실행 중 프로세스 교체 전략 적용 - `PyUpdater`/`Esky` 등 프레임워크 사용 권장).
*   **예외 처리 및 로깅:**
    *   파일 접근 권한 부족, 손상된 파일, 잘못된 인코딩, 네트워크 장애 등 다양한 예외 상황에 대한 사용자 친화적 오류 메시지(`QMessageBox`) 표시 및 내부 로깅.
    *   Python `logging` 모듈 사용, 로그 레벨(DEBUG, INFO, WARNING, ERROR) 적용, 로그 파일 저장(사용자 설정 디렉토리 내).
*   **사용자 설정 관리:**
    *   토큰화 모델, (선택적) 사용자 정의 제외 패턴 등의 설정을 JSON 형식으로 사용자 애플리케이션 설정 디렉토리(플랫폼별 표준 경로, `appdirs` 라이브러리 활용)에 저장.
    *   애플리케이션 시작 시 설정을 로드하고, 종료 시 또는 설정 변경 시 저장하여 지속성 보장.

**Out-of-Scope (초기 버전에 포함되지 않는 기능):**

*   AI 기반 코드 분석, 코드 요약, 자동 프롬프트 생성, 채팅 인터페이스.
*   애플리케이션 내에서의 파일 내용 직접 편집 기능.
*   Git 버전 관리 시스템과의 직접적인 연동 기능 (예: 파일 변경 상태, 브랜치 정보 표시 등).
*   고급 파일 검색(내용 검색 등), 복잡한 필터링 조건, 다중 조건 정렬 기능.
*   XML 복사 또는 사용자가 정의하는 임의의 출력 형식 지원.
*   프로젝트별 설정(선택된 파일 목록, 제외 패턴 등) 저장 및 로드 기능 (초기 버전은 전역 설정 또는 휘발성).
*   플러그인 아키텍처 또는 확장 기능.

**4. 대상 사용자**

*   LLM(ChatGPT, Claude, Gemini, Copilot 등)을 활용하여 코드 관련 질문, 분석, 리팩토링, 문서 생성, 버그 수정 등의 작업을 수행하는 소프트웨어 개발자, 데이터 과학자, 웹 개발자.
*   AI 모델에게 정확하고 충분한 코드 컨텍스트를 제공하여 모델의 응답 품질을 높이고자 하는 AI 엔지니어, 머신러닝 엔지니어, 또는 프롬프트 엔지니어.
*   코드 스니펫, 프로젝트의 특정 부분 구조, 또는 예제 코드를 문서화하거나 팀원과 효율적으로 공유해야 하는 테크니컬 라이터, 교육자, 또는 팀 리더.

**5. 주요 기능 및 산출물**

*   **핵심 산출물:** 사용자 친화적인 GUI를 갖춘 크로스 플랫폼 데스크톱 애플리케이션 (Windows, macOS 용 실행 파일 형태로 배포 권장).
*   **주요 기능 상세 요약:**
    1.  **폴더 로딩 및 시각화:** 직관적인 폴더 선택 및 내부 구조 트리 뷰 표시 (심볼릭 링크/숨김 파일 처리 정책 적용).
    2.  **선택적 포함/제외:** 체크박스 기반의 유연한 선택 (부모/자식 연동) 및 `.gitignore` (또는 사용자 정의) 패턴 기반의 자동 필터링.
    3.  **실시간 토큰 피드백:** 선택된 유효 콘텐츠의 LLM 토큰 수를 즉각적으로 제공하며, 진행 상태 표시.
    4.  **원클릭 복사:** 명확히 정의된 형식의 파일 구조 및 내용을 클립보드로 복사.
    5.  **자동 업데이트:** 프로그램 최신 상태 유지 및 사용자 편의 증진.
    6.  **설정 관리:** 주요 사용자 설정 저장 및 로드.
    7.  **견고한 오류 처리 및 로깅.**

**6. 아키텍처 개요**

*   **UI (사용자 인터페이스) 계층:**
    *   **메인 윈도우:** 애플리케이션의 기본 프레임.
    *   **파일 트리 뷰 위젯:** 체크박스를 포함하며, 폴더 확장/축소 기능을 제공하는 계층적 파일/폴더 목록 표시 영역.
    *   **토큰 수 표시 영역:** 총 토큰 수, 선택된 파일 개수 등을 표시하는 레이블 또는 상태바.
    *   **컨트롤 버튼 영역:** "폴더 열기", "복사", (선택적) "새로고침", "설정" 등의 버튼.
    *   **설정 창 (선택적):** 토큰화 모델 선택, 사용자 정의 제외 패턴 입력, 업데이트 설정 등을 위한 별도 창.
    *   **업데이트 알림 UI:** 새 버전 알림 및 진행 상태 표시.
*   **백엔드 엔진 (애플리케이션 로직) 계층:**
    *   **파일 시스템 분석 모듈:** 지정된 폴더를 재귀적으로 스캔하여 파일 및 폴더 목록 생성. 텍스트 파일과 바이너리 파일을 구분. 텍스트 파일의 내용을 지정된 인코딩으로 읽기 (오류 처리 포함). 심볼릭 링크/숨김 파일 처리 로직 포함.
    *   **제외 패턴 처리 모듈:** `.gitignore` 파일 파싱 및 해당 규칙을 파일/폴더 경로에 적용하여 필터링. (선택적) 사용자 정의 제외 패턴(glob)을 관리하고 필터링에 적용.
    *   **토큰화 모듈:** `tiktoken` 등의 라이브러리를 사용하여 필터링된 텍스트 파일 내용의 LLM 토큰 수를 계산. 선택된 토큰화 모델(인코더)을 기준으로 작업 수행. (다른 LLM 지원은 향후 확장 고려)
    *   **상태 관리 모듈:** 현재 로드된 폴더 경로, 트리 뷰의 각 항목 상태(확장/축소, 체크 여부), 개별 파일/폴더의 토큰 수, 총 토큰 수, 제외된 항목 목록 등 애플리케이션의 주요 상태 정보를 관리.
    *   **출력 포맷팅 모듈:** 상태 관리 모듈로부터 현재 선택되고 필터링된 항목 정보를 받아, 정의된 `<file_map>`과 `<file_contents>` 형식의 최종 문자열을 생성.
    *   **클립보드 제어 모듈:** 생성된 텍스트를 운영체제의 시스템 클립보드로 복사.
    *   **업데이트 확인 및 처리 모듈:** 설정된 업데이트 서버(예: Github Releases API)와 통신하여 최신 버전 정보 확인. 현재 버전과 비교하여 업데이트 필요 여부 판단. 새 버전 패키지 다운로드, 무결성 검증, 정의된 OS별 설치 전략에 따른 자동 설치/교체 로직 수행.
    *   **설정 관리 모듈:** 정의된 형식 및 위치에 사용자 설정(기본 토큰화 모델, 사용자 정의 제외 패턴, 업데이트 주기 등)을 저장하고 로드.
    *   **로깅 모듈 인터페이스:** 백엔드 전반에서 사용될 로깅 기능.
*   **핵심 로직 및 상호작용:**
    *   UI 이벤트를 감지 (버튼 클릭, 체크박스 상태 변경, 폴더 선택)하여 백엔드 모듈의 해당 기능 호출.
    *   파일 스캔, 토큰 계산, 업데이트 확인 등 시간이 오래 걸릴 수 있는 작업은 UI의 반응성을 유지하기 위해 별도의 스레드 또는 비동기 방식으로 처리.
    *   백엔드 처리 결과(예: 토큰 수, 트리 뷰 데이터, 업데이트 상태, 오류 정보)를 UI에 반영하여 사용자에게 피드백.
    *   파일 접근 권한, 네트워크 오류, 잘못된 파일 형식 등 다양한 예외 상황에 대한 견고한 오류 처리 로직 포함.

**7. 기술 스택 (제안)**

*   **프로그래밍 언어:** Python 3.8 이상
*   **GUI 라이브러리:** **PySide6 (우선 권장, LGPL 라이선스)** 또는 PyQt6
*   **토큰화 라이브러리:** `tiktoken` (초기 버전은 OpenAI 모델 집중)
*   **클립보드 제어 라이브러리:** `pyperclip`
*   **파일 시스템 접근:** `pathlib` 모듈, `os` 모듈 (숨김 파일 속성 등 필요시)
*   **`.gitignore` 파싱 라이브러리:** `pathspec` (권장) 또는 `gitignore_parser`
*   **HTTP 요청 라이브러리 (자동 업데이트용):** `requests`
*   **자동 업데이트 프레임워크/라이브러리 (선택적이지만 권장):** `PyUpdater`, `Esky`
*   **버전 문자열 비교:** `packaging.version` (표준 라이브러리에 포함될 수 있음, 없으면 `packaging` 설치)
*   **사용자 설정 디렉토리:** `appdirs` (선택적, 플랫폼별 경로 단순화)
*   **비동기/스레딩:** Python 내장 `threading` 모듈
*   **패키징 도구 (실행 파일 생성용):** `PyInstaller`
*   **설정 파일 처리:** `json` 모듈
*   **로깅:** Python 내장 `logging` 모듈

**8. 개발 단계 및 마일스톤 (예상)**

1.  **Phase 0: 준비 및 설계 (1주)**
    *   요구사항 최종 확정 및 상세 설계 (UI 목업, 데이터 흐름도).
    *   개발 환경 구성 (Python, 가상 환경, 주요 라이브러리 설치 및 테스트).
    *   버전 관리 시스템 설정 (Git, Github Repository 생성).
2.  **Phase 1: 핵심 로직 및 기본 UI 구현 (2주)**
    *   폴더 스캔, 파일 목록 생성, 텍스트/바이너리 구분, 파일 내용 읽기 기능 구현 (파일 처리 세부사항 포함).
    *   기본 토큰화 기능 구현 및 단위 테스트.
    *   메인 윈도우 및 기본 레이아웃 설계 (GUI 프레임워크 선택 확정).
    *   파일 트리 뷰 위젯 기본 구현 (아이콘/툴팁 고려 시작, 체크박스 없이, 구조만 표시).
    *   "폴더 열기" 기능 구현 및 트리 뷰와 연동.
3.  **Phase 2: 핵심 기능 통합 (2-3주)**
    *   트리 뷰에 체크박스 추가 및 선택 상태 관리 기능 구현 (부모/자식 연동 포함).
    *   체크박스 상태 변경에 따른 실시간 토큰 수 계산 로직 구현 (비동기/스레드 처리 적용, 진행 상태 표시 기본 구현).
    *   계산된 토큰 수를 UI에 동적으로 표시하는 기능 구현.
    *   `.gitignore` 파일 파싱 및 파일 필터링 로직 구현 및 통합.
4.  **Phase 3: 복사 기능 및 고급 UI (1-2주)**
    *   선택되고 필터링된 항목 기반으로 정의된 형식의 `<file_map>` 및 `<file_contents>` 생성 로직 구현.
    *   "복사" 버튼 기능 구현 (클립보드 복사).
    *   오류 처리 로직 강화 (오류 메시지 구체화).
    *   UI/UX 개선 (진행 상태 표시 완성, 사용자 알림 등).
    *   (선택적) 설정 창 기본 구현 (토큰화 모델 선택 등).
5.  **Phase 4: 자동 업데이트 기능 및 설정 관리 (2-3주)**
    *   업데이트 서버 연동 로직 구현 (Github Releases API 사용).
    *   버전 비교 및 업데이트 필요 여부 판단 로जिक 구현.
    *   새 버전 패키지 다운로드 및 무결성 검증 로직 구현.
    *   자동 설치/교체 로직 구현 (OS별 전략, 프레임워크 사용 고려).
    *   업데이트 관련 사용자 알림 UI 구현.
    *   설정 저장/로드 기능 구현 (JSON 파일, 표준 경로 사용).
6.  **Phase 5: 통합 테스트, 최적화 및 배포 준비 (2주)**
    *   모든 기능에 대한 통합 테스트 수행 (다양한 폴더 구조, 파일 형식, `.gitignore` 규칙, 네트워크 환경, OS별).
    *   성능 테스트 (대용량 폴더 처리 속도, 메모리 사용량) 및 최적화.
    *   사용성 테스트 및 피드백 반영.
    *   최종 실행 파일 패키징 (Windows, macOS) 및 각 플랫폼에서의 테스트.
    *   사용자 문서(간단한 사용법, FAQ) 초안 작성.

*   *총 예상 기간: 약 10-13주. 이는 단일 개발자 기준이며, 팀 규모, 개발자 숙련도, 병행 작업 가능 여부에 따라 크게 변동될 수 있습니다.*

**9. 잠재적 위험 요소 및 완화 방안**

*   **성능 저하 (대용량 폴더 처리 시):**
    *   위험: 파일 스캔, `.gitignore` 규칙 적용, 토큰 계산 시 애플리케이션 응답성 저하 또는 멈춤.
    *   완화: 모든 I/O 바운드 및 CPU 바운드 작업을 별도 스레드 또는 비동기 방식으로 처리. 파일/폴더 정보 및 토큰 수에 대한 캐싱 전략 적용. 처리 중 사용자에게 명확한 진행 상태(프로그레스 바 등) 표시. (선택적) 매우 큰 파일에 대한 처리 제한 또는 경고 옵션 제공.
*   **UI/UX 복잡성 및 구현 난이도:**
    *   위험: 직관적이고 반응성이 뛰어난 파일 트리 뷰(특히 체크박스 연동), 실시간 업데이트, 크로스 플랫폼 UI 일관성 확보의 어려움.
    *   완화: 검증된 GUI 라이브러리(PyQt/PySide 권장) 사용 및 해당 라이브러리의 고급 기능 적극 활용. UI 디자인 단계에서 사용자 시나리오 기반 목업 및 프로토타이핑 진행. 단계별 기능 구현 및 반복적인 사용자 테스트.
*   **토큰 계산 정확성 및 다양한 LLM 지원:**
    *   위험: 사용하는 LLM 모델과 `tiktoken`의 특정 인코더 간의 토큰화 방식 불일치 또는 새로운 모델에 대한 미지원.
    *   완화: `tiktoken` 라이브러리의 공식 문서 및 업데이트 사항 지속적 확인. 지원하는 인코더(모델) 목록을 명확히 하고, 사용자가 선택할 수 있도록 옵션 제공. 주요 LLM 모델별 토큰화 방식 차이 인지 및 필요시 추가 라이브러리 통합 가능성 열어둠 (다른 LLM 지원은 명확히 후순위).
*   **`.gitignore` 파싱 및 적용의 복잡성:**
    *   위험: 매우 복잡하거나 표준을 벗어난 `.gitignore` 규칙(부정 패턴, 디렉토리 전용 패턴, 심볼릭 링크 경로 등) 처리 시 오류 발생 또는 예상과 다른 필터링 결과.
    *   완화: 널리 사용되고 검증된 `.gitignore` 파싱 라이브러리(`pathspec` 등) 사용. 라이브러리의 지원 범위 및 한계 명확히 파악. 다양한 실제 `.gitignore` 파일을 사용한 충분한 테스트 수행. 숨김 파일/심볼릭 링크 처리 정책과 연계하여 일관성 유지.
*   **자동 업데이트 구현의 복잡성 및 안정성:**
    *   위험: 플랫폼별(Windows, macOS) 업데이트 방식 차이, 관리자 권한 요구, 방화벽/백신 프로그램과의 충돌, 업데이트 중단 시 애플리케이션 손상, 안정적인 업데이트 서버 운영 부담.
    *   완화: `PyUpdater`, `Esky`와 같은 자동 업데이트 전문 프레임워크 사용 적극 고려 (구현 복잡도 크게 낮춤). Github Releases와 같은 외부 플랫폼을 버전 관리 및 배포 채널로 활용. HTTPS를 통한 안전한 다운로드 보장. 업데이트 전 사용자 동의 및 명확한 안내. 업데이트 실패 시 롤백 메커니즘 또는 수동 업데이트 방법 명시. **OS별 설치/권한 전략 구체화 및 테스트 필수.**
*   **크로스 플랫폼 호환성 문제:**
    *   위험: 파일 경로 처리(대소문자 구분 등), UI 렌더링 차이, 시스템 권한, 숨김 파일 속성 등에서 운영체제별 차이로 인한 버그 발생.
    *   완화: `pathlib`과 같이 플랫폼 독립적인 경로 처리 라이브러리 사용. GUI 라이브러리의 크로스 플랫폼 지원 기능 최대한 활용. 각 대상 플랫폼(Windows, macOS)에서 충분한 테스트 수행. OS별 특성(예: macOS 메뉴 바) 고려.
*   **Scope Creep (기능 범위의 무분별한 확장):**
    *   위험: 개발 과정에서 초기 계획에 없던 새로운 기능 추가 요구가 지속적으로 발생하여 프로젝트 일정 지연 및 리소스 고갈.
    *   완화: 본 계획 문서의 'In-Scope' 및 'Out-of-Scope' 항목을 기준으로 기능 개발 우선순위 명확히 관리. 추가 기능 요구는 별도의 백로그로 관리하고, 초기 버전 안정화 이후 다음 릴리스 계획으로 검토.
*   **데이터 손실 위험 (설정 파일 등):**
    *   위험: 설정 파일 저장/로드 시 오류로 인한 사용자 설정 유실.
    *   완화: 설정 파일 쓰기 전 백업, 저장된 데이터의 유효성 검사 로직 추가, 오류 발생 시 사용자에게 알리고 기본값으로 안전하게 복구하는 메커니즘 구현.

**10. 가정**

*   사용자는 자신의 로컬 컴퓨터 환경에 대한 기본적인 이해와 파일/폴더 조작 능력을 갖추고 있다.
*   애플리케이션을 실행할 대상 시스템은 최소한의 시스템 요구사항(운영체제 버전, 메모리 등)을 충족한다.
*   사용자는 LLM의 토큰 개념과 컨텍스트 윈도우의 중요성에 대해 기본적인 이해를 가지고 있다.
*   자동 업데이트 기능을 위해 애플리케이션이 인터넷에 연결될 수 있는 환경이다.

**11. 향후 개선 방향 (선택적, 초기 버전 릴리스 이후 고려 사항)**

*   **사용자 정의 제외/포함 패턴 강화:** UI를 통해 사용자가 직접 제외할 파일/폴더 패턴뿐만 아니라, 반드시 포함할 패턴도 정의할 수 있는 기능.
*   **프로젝트별 설정 저장:** 최근 열었던 폴더 목록, 해당 폴더별 선택된 파일/제외 패턴 등을 저장하여 재사용성 증대.
*   **파일 내용 미리보기 창:** 트리 뷰에서 파일을 선택했을 때, 해당 파일의 내용을 간단히 확인할 수 있는 읽기 전용 미리보기 패널 추가.
*   **출력 형식 커스터마이징 옵션:** `<file_map>` 또는 `<file_contents>`의 세부 형식(들여쓰기, 주석 포함 여부 등)을 사용자가 일부 조정할 수 있는 옵션 제공.
*   **파일 이름 기반 검색 기능:** 트리 뷰에 로드된 파일 목록 내에서 특정 이름이나 패턴으로 파일을 빠르게 검색하는 기능.
*   **다국어 지원 (i18n):** UI 텍스트를 여러 언어로 제공하여 글로벌 사용자 지원.
*   **테마 지원:** 라이트/다크 모드 등 사용자 인터페이스 테마 변경 기능.
*   **심볼릭 링크 따라가기 옵션:** 사용자가 설정에서 심볼릭 링크 대상의 내용을 포함할지 여부 선택 기능.
*   **다른 LLM 토크나이저 지원 확장:** Claude, Gemini 등 다른 주요 LLM 모델의 토큰화 지원 추가.

**12. 결론**

본 최종 프로젝트 계획 문서는 사용자 질문에 대한 답변을 통합하여, `.gitignore` 스타일의 파일 제외 기능과 자동 업데이트 기능을 포함하며, LLM 프롬프트 작성의 효율성과 편의성을 극대화하는 코드 스니펫 생성 도우미 개발을 위한 포괄적인 가이드라인을 제시합니다. 명확한 목표 설정, 구체적인 범위 정의, 적절한 기술 스택 제안, 체계적인 개발 단계 및 위험 관리 계획을 바탕으로, 사용자에게 실질적인 가치를 제공하는 고품질 애플리케이션의 성공적인 개발 및 릴리스를 목표로 합니다. 본 도구는 LLM을 활용하는 개발자 및 관련 전문가들의 작업 흐름을 개선하고 생산성을 높이는 데 중요한 역할을 할 것으로 기대됩니다.