# LLM 프롬프트 헬퍼: 상세 구현 계획 (v1.3)

## 목표:
제공된 프로젝트 계획서(v1.3), 기술 스택, 코딩 규칙을 바탕으로 "LLM 프롬프트용 코드 스니펫 생성 도우미" 데스크톱 애플리케이션을 구현합니다. 이 계획은 AI 개발자(Claude 등)가 따라 할 수 있도록 단계별 지침과 각 단계의 검증 방법을 명시합니다. 코드 자체는 포함하지 않습니다.

**참고 문서:**
*   프로젝트 계획서 v1.3 (이전 대화의 최종 버전)
*   기술 스택 요약 (이전 대화의 최종 버전)
*   코딩 규칙 (`.cursor/rules/rules.mdc` 내용)

---

## Phase 0: 준비 및 설계 (예상: 1주)

**목표:** 개발 환경 설정, 프로젝트 구조 생성, 기본 GUI 창 생성.

*   **단계 1: 개발 환경 설정**
    *   **지침:**
        1.  Python 3.8 이상 설치 확인.
        2.  `pip` 설치 확인.
        3.  프로젝트 디렉토리 생성.
        4.  프로젝트 디렉토리 내 가상 환경 생성.
        5.  가상 환경 활성화.
    *   **검증:** 터미널 프롬프트 앞에 가상 환경 표시 확인, 활성화 환경에서 `python` 및 `pip` 버전 확인.

*   **단계 2: 핵심 의존성 설치**
    *   **지침:** 활성화된 가상 환경에서 requirements.txt를 이용하여 `PySide6` (또는 `PyQt6`), `tiktoken`, `pathspec`, `pyperclip`, `requests`, `packaging`, `appdirs` (선택적이지만 권장) 라이브러리 설치.
    *   **검증:** `pip freeze` 또는 `pip list`로 설치된 라이브러리 목록 및 버전 확인.

*   **단계 3: 프로젝트 구조 생성**
    *   **지침:** 코딩 규칙에 따라 `src/`(main.py, gui/, core/, utils/), `tests/`, `venv/` 디렉토리 구조 생성. `src/core/` 내에 `file_scanner.py`, `tokenizer.py`, `filter.py`, `output_formatter.py` 등 초기 모듈 파일 생성. `src/gui/` 내에 `main_window.py`, `settings_dialog.py` (선택적) 등 초기 UI 파일 생성.
    *   **검증:** 파일 탐색기 또는 명령어로 지정된 디렉토리 및 초기 파일 구조 생성 확인.

*   **단계 4: 버전 관리 시스템 설정**
    *   **지침:** 프로젝트 루트에서 Git 저장소 초기화, `.gitignore` 파일 생성 및 Python 제외 패턴 추가, 초기 파일 구조 스테이징 및 첫 커밋 생성.
    *   **검증:** `git status`로 깨끗한 상태 확인, `git log`로 첫 커밋 기록 확인.

*   **단계 5: 기본 GUI 창 생성 및 레이아웃 정의**
    *   **지침:** `src/main.py`와 `src/gui/main_window.py` 모듈 생성. `main_window.py`에 `PySide6`를 사용하여 메인 `QMainWindow` 생성. 주요 UI 영역(왼쪽 트리 뷰 패널, 오른쪽/하단 선택 요약 및 액션 패널)을 위한 기본 레이아웃(예: `QSplitter`, `QVBoxLayout`, `QHBoxLayout`) 설정. "폴더 열기", "복사" 버튼, 총 토큰 수 표시용 `QLabel` 자리 표시자 추가.
    *   **검증:** `python src/main.py` 실행 시 기본 레이아웃을 갖춘 빈 데스크톱 창 오류 없이 나타나고 정상적으로 닫히는지 확인.

---

## Phase 1: 핵심 로직 및 기본 UI 구현 (예상: 2주)

**목표:** 파일 시스템 스캔, 토큰화 기본 로직 구현, 기본 트리 뷰 UI 구현 및 연동, 파일 처리 세부사항 구현.

*   **단계 6: 파일 시스템 스캔 로직 구현 (심볼릭 링크, 숨김 파일 처리 포함)**
    *   **지침:** `src/core/file_scanner.py` 모듈에 `pathlib` 사용하여 지정 디렉토리 재귀 스캔, 파일/폴더 경로 목록 반환 함수 구현. `pathlib.Path.is_symlink()`로 심볼릭 링크 식별 (기본적으로 따라가지 않음). 파일명이 `.`으로 시작하거나 OS별 숨김 속성 가진 파일/폴더 식별 로직 추가. 기본 파일 접근 권한 오류 처리 포함.
    *   **검증:** 다양한 테스트 폴더(심볼릭 링크, 숨김 파일 포함)로 함수 테스트, 반환된 경로 목록과 실제 폴더 구조 일치 확인, 접근 불가 폴더 입력 시 예외 처리 동작 확인. 심볼릭 링크와 숨김 파일이 올바르게 식별되는지 확인.

*   **단계 7: 텍스트/바이너리 파일 식별 및 UI 표시 로직 추가**
    *   **지침:** `file_scanner.py` 또는 `utils` 모듈에 파일 경로 입력받아 텍스트/바이너리 구분 함수 추가. 구분된 정보를 스캔 결과에 포함. 트리 뷰 아이템 생성 시 바이너리 파일에 대해 특정 아이콘 또는 텍스트(예: "(바이너리)")를 표시하도록 준비.
    *   **검증:** 알려진 텍스트/바이너리 파일 경로 입력 테스트, 각 파일 타입에 대한 올바른 분류 결과 반환 확인.

*   **단계 8: 파일 내용 읽기 및 인코딩 처리 로직 구현**
    *   **지침:** `file_scanner.py`에 식별된 텍스트 파일 경로 받아 내용 문자열로 읽어오는 함수 구현. 기본 UTF-8 인코딩 시도, 실패 시 `UnicodeDecodeError` 처리 (None 반환 또는 오류 기록, 해당 파일은 토큰 계산에서 제외됨을 명시).
    *   **검증:** 다양한 인코딩 샘플 텍스트 파일 읽기 테스트, 파일 내용 정확히 문자열로 반환 확인. 읽을 수 없는 파일(권한, 인코딩 문제)에 대해 오류 처리 및 해당 정보(예: 읽기 실패 상태)가 반환되는지 확인.

*   **단계 9: 기본 토큰화 로직 구현 (OpenAI 모델 기준)**
    *   **지침:** `src/core/tokenizer.py` 모듈 생성. `tiktoken` 사용하여 문자열(파일 내용) 입력받아 지정 모델(기본 "gpt-3.5-turbo") 기준 토큰 수 계산 반환 함수 구현. 파일 읽기 실패 시(None 입력 등) 토큰 수 0 또는 특정 오류 값 반환.
    *   **검증:** 다양한 샘플 문자열/실제 파일 내용 입력 테스트, 반환된 토큰 수 예상치와 일치 확인. 빈 문자열/None 입력 시 예외 처리 또는 적절한 값 반환 확인.

*   **단계 10: 파일 트리 뷰 UI 구현 (아이콘, 툴팁 포함)**
    *   **지침:** `src/gui/main_window.py`에 `QTreeView` 위젯과 `QStandardItemModel` 설정. 각 아이템에 대해 파일/폴더 아이콘, 심볼릭 링크 아이콘, 바이너리 파일 아이콘 등을 구분하여 표시. 파일 읽기 실패 시 경고 아이콘(⚠️) 및 툴팁으로 오류 요약 표시 준비.
    *   **검증:** 애플리케이션 실행 시 메인 윈도우에 트리 뷰 표시. 다양한 파일/폴더 타입에 대해 아이콘이 올바르게 표시되는지 확인.

*   **단계 11: 스캔 로직과 트리 뷰 연동 (숨김 파일 토글 옵션 준비)**
    *   **지침:** 메인 윈도우 "폴더 열기" 액션/버튼 클릭 시 `QFileDialog.getExistingDirectory`로 폴더 경로 입력. 입력 경로 스캔 함수(단계 6) 호출. 반환된 파일/폴더 목록(식별 정보 포함)으로 `QTreeView` 모델 동적 생성 및 채우기 (체크박스 미포함). (선택적) "숨김 파일/폴더 표시" UI 토글 옵션 자리 표시자 및 기본 로직 준비.
    *   **검증:** "폴더 열기"로 실제 로컬 폴더 선택. 트리 뷰가 선택 폴더 실제 파일/하위 폴더 구조 정확히 반영 표시 확인. 심볼릭 링크, 바이너리 파일 등이 올바르게 표시되는지 확인.

---

## Phase 2: 핵심 기능 통합 및 필터링 (예상: 2-3주)

**목표:** 트리 뷰에 체크박스 추가 (부모/자식 연동), 상태 관리, `.gitignore` 파싱 및 필터링 적용, 백그라운드 토큰 계산 (진행 상태 표시 포함), 실시간 총 토큰 수 업데이트 구현.

*   **단계 12: 트리 뷰에 체크박스 추가 및 기본 상태 관리**
    *   **지침:** `QStandardItemModel` 아이템 생성 시 `setCheckable(True)` 호출. 트리 뷰 모델 `itemChanged` 시그널 슬롯 연결, 변경된 아이템 체크 상태 감지, 현재 체크된 항목 목록(경로 기준) 관리 내부 자료구조 업데이트.
    *   **검증:** 폴더 열었을 때 트리 뷰 모든 항목 앞에 체크박스 표시 확인. 체크박스 클릭 시 시각적 상태 변경 및 내부 목록 업데이트 확인.

*   **단계 13: 체크박스 부모/자식 자동 선택/해제 로직 구현**
    *   **지침:** 단계 12의 `itemChanged` 슬롯 로직 확장. 부모 폴더 체크 시 하위 모든 항목 재귀적 자동 체크/해제. 모든 하위 항목 체크 시 부모 폴더 자동 체크. (모든 하위 해제 시 부모 자동 해제 또는 부분 선택 상태 고려 - 초기엔 단순 해제).
    *   **검증:** 부모 폴더 체크/해제 시 하위 항목 상태 연동 확인. 모든 자식 체크 시 부모 자동 체크 확인. 자식 중 하나라도 해제 시 부모 자동 해제(또는 부분 선택) 확인.

*   **단계 14: `.gitignore` 파싱 로직 구현**
    *   **지침:** `src/core/filter.py` 모듈 생성. `pathspec` 사용하여 주어진 루트 디렉토리 경로에서 `.gitignore` 파일 찾아 내용 읽고 파싱, `PathSpec` 객체 반환 함수 구현. `.gitignore` 파일 없거나 읽기 오류 시 적절 처리.
    *   **검증:** 다양한 규칙 포함 여러 `.gitignore` 파일 테스트. 함수가 규칙 올바르게 로드, `PathSpec` 객체 생성 확인. `.gitignore` 파일 없는 경우/읽기 오류 시 예외 처리 또는 기본값 반환 확인.

*   **단계 15: 스캔/표시 시 `.gitignore` 필터링 적용**
    *   **지침:** 단계 11 폴더 스캔/트리 뷰 채우기 로직 수정. 스캔된 각 파일/폴더 경로에 대해 단계 14 `PathSpec` 객체 `match_file()`로 `.gitignore` 규칙 일치 확인. 일치 항목 트리 뷰에 추가 않거나 시각적 구분(예: 회색 처리, 체크박스 비활성화).
    *   **검증:** `.gitignore` 파일과 해당 규칙 맞는 파일/폴더 포함 폴더 열기. 트리 뷰에서 무시 항목 실제 미표시 또는 의도한 시각적 구분 확인. 부정 패턴(`!`) 명시 포함 항목 올바르게 표시 확인.

*   **단계 16: 백그라운드 토큰 계산 로직 및 진행 상태 표시 구현**
    *   **지침:** 폴더 열릴 때 필터링되지 않은 텍스트 파일 토큰 수 계산 작업 `threading.Thread`로 백그라운드 실행. 각 파일 경로/계산 토큰 수 매핑 딕셔너리(토큰 캐시) 관리. 토큰 계산 중 오류(파일 읽기 실패 포함) 처리 및 캐시에 `None` 또는 오류 값 기록. 상태 표시줄 메시지("토큰 계산 중 (N/M 파일)...") 및 프로그레스 바(모달 또는 상태 표시줄 내)로 진행 상태 표시.
    *   **검증:** 파일 많은 폴더 열기. 토큰 계산 중 GUI 반응성 유지, 상태 메시지/프로그레스 바 업데이트 확인. 계산 완료 후 토큰 캐시 정확성 확인. 읽기 실패 파일 처리 확인.

*   **단계 17: 실시간 총 토큰 수 계산 및 표시 (필터링, 오류 파일 제외)**
    *   **지침:** 메인 윈도우 총 토큰 수 표시 `QLabel` 업데이트 로직 구현. 단계 13 체크박스 상태 변경 감지 슬롯에서, 현재 체크된 항목 중 **필터링되지 않았고, 텍스트 파일이며, 토큰 캐시에 유효한 토큰 수가 있는** 항목들의 토큰 수만 합산. 합산된 총 토큰 수를 메인 스레드에서 `QLabel` 업데이트.
    *   **검증:** 다양한 파일/폴더 체크박스 선택/해제. 총 토큰 수 레이블 즉시, 정확하게 업데이트 확인. 필터링 항목, 바이너리 파일, 읽기 실패 파일 체크해도 총 토큰 수에 영향 없는지 확인.

---

## Phase 3: 복사 기능 및 고급 UI (예상: 1-2주)

**목표:** 정의된 형식의 `<file_map>`, `<file_contents>` 생성 로직 구현, "복사" 버튼 기능 구현, 오류 처리 및 UI 개선.

*   **단계 18: `<file_map>` 생성 로직 구현 (정의된 형식 적용)**
    *   **지침:** `src/core/output_formatter.py` 모듈 생성. 현재 체크되고 필터링되지 않은 항목 목록/전체 폴더 구조 정보 입력받아, 프로젝트 계획서에 정의된 형식(들여쓰기, 디렉토리/파일 표시)의 `<file_map>` 문자열 생성 함수 구현. 루트 폴더 기준 상대 경로 사용.
    *   **검증:** 다양한 파일/폴더 조합 체크 상태에서 함수 호출. 생성 문자열이 정의된 `<file_map>` 형식/내용(선택 항목만 포함) 정확히 따르는지 확인.

*   **단계 19: `<file_contents>` 생성 로직 구현 (언어 식별자 매핑 포함)**
    *   **지침:** `output_formatter.py`에 현재 체크되고 필터링되지 않은 파일 목록(경로 포함) 입력받는 함수 구현. 각 파일 내용 다시 읽고(오류 처리 포함), 정의된 형식(`File: [상대 경로]\n\`\`\`[언어 식별자]\n[파일 내용]\n\`\`\`\n`) 맞춰 문자열 생성, 모두 결합. 파일 확장자-언어 식별자 매핑 테이블(예: `.py`->`python`) 사용.
    *   **검증:** 여러 텍스트 파일 체크 상태에서 함수 호출. 생성 문자열에 각 선택 파일 정확한 상대 경로/전체 내용 포함, 요구 형식(코드 블록, 올바른 언어 식별자) 따르는지 확인.

*   **단계 20: "복사" 버튼 기능 구현 및 피드백**
    *   **지침:** 메인 윈도우 "복사" `QPushButton` 클릭 시, 현재 체크/필터링 항목 목록 가져오기. 단계 18, 19 함수 호출 `<file_map>`, `<file_contents>` 문자열 생성, 결합. `pyperclip.copy()`로 클립보드 복사. 상태 표시줄에 "N개 파일 (M 토큰) 클립보드에 복사됨" 메시지 표시.
    *   **검증:** 다양한 항목 선택, "복사" 버튼 클릭. 텍스트 편집기 붙여넣기. 붙여넣은 내용 정확성 확인. 상태 표시줄 성공 메시지 확인.

*   **단계 21: 오류 처리 및 사용자 피드백 개선 (메시지 박스, 로깅 연동)**
    *   **지침:** 애플리케이션 전반 오류 처리 로직 검토/개선. 파일 접근 불가, 잘못된 인코딩, 토큰화 실패 등 사용자 친화적 `QMessageBox`로 명확한 오류 메시지 표시. 내부적으로는 `logging` 모듈 사용하여 상세 오류 정보 파일에 기록.
    *   **검증:** 의도적 다양한 오류 상황 생성. 프로그램 미종료, 사용자 이해 쉬운 오류 메시지 상자 표시, 로그 파일에 상세 정보 기록 확인.

*   **단계 22: 설정 UI 기본 구현 (토큰화 모델 선택)**
    *   **지침:** 사용자가 토큰화 기준 LLM 모델(초기엔 `tiktoken` 내 모델)을 선택할 수 있는 간단한 설정 다이얼로그(`QDialog`) 및 관련 로직 구현. 선택된 모델은 토큰 계산에 반영.
    *   **검증:** 설정 다이얼로그에서 모델 변경 시 총 토큰 수가 해당 모델 기준으로 재계산되어 UI에 반영되는지 확인.

---

## Phase 4: 자동 업데이트 기능 및 설정 관리 (예상: 2-3주)

**목표:** 버전 관리, 업데이트 확인 로직, 사용자 알림, (고급) 자동 설치/교체, 사용자 설정 저장/로드 구현.

*   **단계 23: 애플리케이션 버전 관리 및 표시**
    *   **지침:** 프로젝트 특정 위치에 애플리케이션 현재 버전 변수 정의. "정보(About)" 대화상자 등에 현재 버전 표시.
    *   **검증:** 정보 대화상자 또는 로그에서 현재 버전 올바르게 출력 확인.

*   **단계 24: 업데이트 확인 로직 구현 (Github Releases API, 버전 비교)**
    *   **지침:** Github Releases API 엔드포인트 사용하여 최신 릴리스 정보 JSON 가져오는 함수 구현. JSON 응답 최신 버전 번호 추출. `packaging.version` 사용하여 현재 버전과 비교. 프로그램 시작 시 또는 메뉴 액션 클릭 시 백그라운드 스레드 실행. 네트워크 오류 예외 처리.
    *   **검증:** Github Repository 릴리스 테스트. 버전 비교 로직 정확성, 네트워크 오류 처리 확인.

*   **단계 25: 업데이트 알림 UI 구현 (다운로드 페이지 링크)**
    *   **지침:** 새 버전 발견 시 `QMessageBox`로 "새 버전(vX.Y.Z) 사용 가능. 다운로드 페이지 이동?" 메시지와 버튼 제공. "예" 클릭 시 `webbrowser.open()`으로 Github Releases 페이지 열기.
    *   **검증:** 업데이트 알림 메시지 상자 정확성, 버튼 동작 확인.

*   **단계 26 (고급 - 선택적): 자동 설치/교체 프레임워크 도입 또는 기본 전략 구현**
    *   **지침:** `PyUpdater` 또는 `Esky` 도입 검토. 직접 구현 시, OS별 권한 및 실행 중 프로세스 교체 전략(새 버전 임시 다운로드 -> 재시작 시 교체 등) 수립 및 구현.
    *   **검증:** (구현 시) 프레임워크 테스트 절차 또는 시뮬레이션 통해 새 버전 성공적 교체/정상 실행, 오류 상황 복구/안내 확인.

*   **단계 27: 사용자 설정 저장/로드 기능 구현 (JSON, 표준 경로)**
    *   **지침:** 토큰화 모델 등 사용자 설정을 JSON 형식으로 사용자 애플리케이션 설정 디렉토리(플랫폼별 표준 경로, `appdirs` 사용)에 저장/로드하는 로직 구현. 앱 시작 시 로드, 종료 또는 설정 변경 시 저장.
    *   **검증:** 설정 변경 후 앱 재시작 시 변경된 설정 유지 확인. 설정 파일 손상/부재 시 기본값으로 안전하게 복구 확인.

---

## Phase 5: 통합 테스트, 최적화 및 배포 준비 (예상: 2주)

**목표:** 애플리케이션의 전체적인 안정성, 성능, 사용성을 검증하고 배포 가능한 형태로 패키징.

*   **단계 28: 종합적인 통합 테스트 (OS별, 다양한 시나리오)**
    *   **지침:** 개발된 모든 기능 조합 다양한 시나리오(대용량 폴더, 복잡한 `.gitignore`, 다양한 파일 타입/크기, 오류 유발, OS별) 테스트.
    *   **검증:** 모든 테스트 시나리오 예상대로 동작, 강제 종료 안 됨, 데이터 정확성, 플랫폼 간 동작 일관성 확인.

*   **단계 29: 성능 프로파일링 및 최적화**
    *   **지침:** `cProfile` 등 사용하여 성능 병목 구간 식별(폴더 스캔, 토큰 계산, UI 업데이트). 코드 최적화.
    *   **검증:** 최적화 후 이전 성능 저하 시나리오 반응 속도/자원 사용량 개선 측정/확인. 일반 사용 환경 쾌적한 성능 제공 주관적 평가.

*   **단계 30: 최종 UI/UX 검토 및 개선 (일관성, 명확성)**
    *   **지침:** 전체 UI/UX 검토. 위젯 배치, 라벨링, 아이콘, 메시지 문구 명확성/일관성 확인. 필요시 툴팁, 도움말 추가. 플랫폼별 UI 가이드라인 참고.
    *   **검증:** 제3자 피드백. UI 직관적, 사용 편리, 전문적 느낌 확인.

*   **단계 31: 애플리케이션 패키징 (PyInstaller, OS별 빌드)**
    *   **지침:** `PyInstaller` 사용하여 Windows/macOS용 독립 실행 파일 생성. `.spec` 파일 수정(아이콘, 의존성, 데이터 파일 등). 각 플랫폼별 빌드/패키징.
    *   **검증:** 패키징 과정 오류 없이 완료 확인. 생성 실행 파일 깨끗한 테스트 환경에서 실행. 패키징 앱 정상 실행, 모든 기능 개발 환경과 동일 동작 철저 검증.

*   **단계 32: 기본 사용자 문서 작성 (README.md)**
    *   **지침:** `README.md` 파일 작성. 애플리케이션 목적, 주요 기능, 설치 방법, 간단한 사용법 가이드, 알려진 문제점/제약 사항 명확/간결 기술.
    *   **검증:** 작성 문서 읽었을 때 처음 사용자 앱 설치/기본 기능 이해/사용 가능한지 확인. 내용 정확/최신 상태 확인.

---

**지속적인 활동:**

*   **코드 리뷰 및 리팩토링:** 각 단계 완료 후 또는 주기적으로 작성 코드 검토, 코딩 규칙 준수 확인. 필요시 코드 리팩토링.
*   **버전 관리:** 각 의미 있는 변경 사항/단계 완료 시 Git 커밋, 필요시 브랜치 활용 기능 개발.
*   **로깅 확인:** 개발 및 테스트 중 로그 파일을 주기적으로 확인하여 잠재적 문제점 파악.